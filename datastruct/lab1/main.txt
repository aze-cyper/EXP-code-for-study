#include<iostream>
#include<cstring>
#include<cctype>
using namespace std;
//创建节点结构体
struct Node{
    int data;
    Node * next;
};
//创建整个栈结构体
struct Stack{
    Node * top;
};
//初始化栈，使栈顶指针指向零
void initstack(Stack & s){
    s.top = nullptr;
};
//判断栈是否为空
/*bool isempty(const Stack & s){
    if(s.top == nullptr){
        return true;
    }
    else{
        return false;
    }
}*/
//简化版本
bool isempty(const Stack & s){
    return s.top == nullptr;
}
//压栈，创建新节点，新节点的next为原来的top，新top为新节点的地址
void push(Stack & s,int value){
    Node * newelement = new Node;
    newelement -> data = value;
    newelement -> next = s.top;
    s.top = newelement;
}
//弹栈
int pop(Stack & s){
    if(isempty(s)){
        return -1;
    }
    else{
        //初始化temp指向node,用来保存s.top
        Node * temp;
        temp = s.top;
        int value = temp -> data;
        //更改top，使栈顶变为下一个
        s.top = s.top -> next;
        delete temp;
        return value;
    }
}
//查看并复制栈顶元素
bool peek(const Stack & s,int & out){
    if(isempty(s)){
        return false;
    }
    else{
        out = s.top -> data;
        return true;
    }
}
//打印栈
void printstack(const Stack & s){
    Node * temp = s.top;
    while(temp != nullptr){
        cout << temp -> data << endl;
        temp = temp -> next;
    }
}
//清理栈
void clearstack(Stack & s){
    while(s.top != nullptr){
        Node * temp;
        temp = s.top;
        s.top = s.top -> next;
        delete temp;    
    }
}
//保存并显示中缀表达式
string inputexpression(string s){
    string s1;
    for(int i = 1;i < s.size();i++){
        //由于char结尾有'\0',string的结尾没有'\0',直接使用s.size()判断s的大小
        if(s[i] == '#'){
            break;
        }
        if(s[i] == ' '){
            continue;
        }
        s1 += s[i];
    }
    cout << s1 << endl;
    return s1;
}
//判断运算符优先级
int priority(char c){
    if(c == '+' || c == '-'){return 1;}
    else if(c == '*' || c == '/'){return 2;}
    else{return 0;}
}
bool isRightAssociative(char op) {
    return false; // 暂时全是左结合
}

//中缀表达式转后缀表达式
string InfixToPostfix(string s0, Stack s) {
    string result;
    for (int i = 0; i < s0.size(); i++) {
        //处理数字
        if (isdigit(s0[i])) {
            string number;
            number += s0[i];
            while (i + 1 < s0.size() && isdigit(s0[i + 1])) {
                //循环，确定接下来几位是数字
                number += s0[i + 1];
                i++;
            }
            result += number + " "; // 数字直接加入结果
        }
        // 2. 处理左括号 '('
        else if (s0[i] == '(') {
            push(s, s0[i]); // 左括号直接压栈
        }
        // 3. 处理右括号 ')'
        else if (s0[i] == ')') {
            // 弹出栈顶元素并加入结果，直到遇到左括号
            while (!isempty(s) && s.top->data != '(') {//不为空，并且未遇到左括号
                result += string(1, pop(s)) + " ";//弹出单个为char，需要转换为string
            }
            pop(s); // 弹出左括号 '(' 但不加入结果
        }
        // 4. 处理操作符 ('+', '-', '*', '/')
        else if (s0[i] == '*' || s0[i] == '/' || s0[i] == '+' || s0[i] == '-') {
            // 当栈不为空，且栈顶操作符优先级 >= 当前操作符优先级时，并且需要判断栈不为空
            while (!isempty(s) && s.top->data != '(' && 
                   priority(s.top->data) >= priority(s0[i])) {
                    //高优先级入栈，低优先级输出
                result += string(1, pop(s)) + " ";
            }
            // 将当前操作符压入栈中
            push(s, s0[i]);
        }
    } // for 循环结束

    // 5. 将栈中剩余的所有操作符弹出并加入结果
    while (!isempty(s)) {
        result += string(1, pop(s)) + " ";
    }

    return result;
}
int evaluatepostfix(string s0,Stack s){
    int result;
    for(int i = 0;i < s0.size();i++){
        //1、遇到数字压栈
        if(isdigit(s0[i])){
            string number;
            number += s0[i];
            while(i + 1 < s0.size() && isdigit(s0[i+1])){
                number += s0[i+1];
                i++;
            }
            int value = stoi(number);
            push(s,value);
        }
        else if(s0[i] == ' '){
            continue;
        }
        //2、遇到运算符弹栈，弹出俩个数字
        else{
            //使用stoi把string类型转换为int类型
            int right = pop(s);
            int left = pop(s);
            //进行运算
            int temp = 0;
            switch(s0[i]){
                case '+' : temp = left + right;break;
                case '-' : temp = left - right;break;
                case '*' : temp = left * right;break;
                case '/' : temp = left / right;break;
            }
            push(s,temp);
        }
    }
    result = pop(s);
    return result;
}
int main(){  
    Stack s;
    initstack(s);
    string s1;
    getline(cin,s1);
    cout << InfixToPostfix(s1,s) << endl;
    int value = evaluatepostfix(InfixToPostfix(s1,s),s);
    cout << value << endl;
    system("pause");
    return 0;
}